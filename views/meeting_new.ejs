<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Availability</title>
    <link rel="stylesheet" href="/styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.33/moment-timezone-with-data.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.1.1/dist/chartjs-chart-matrix.min.js"></script>

</head>
<body>
<h1>Meeting Availability Heatmap</h1>
<div style="width: 100%; height: 400px;">
    <canvas id="availability-heatmap"></canvas>
</div>
<div id="best-time"></div>
<div id="participants-list">
    <h2>Participants</h2>
    <ul id="participant-colors">
        <!-- We'll populate this list dynamically -->
    </ul>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const participants = <%- JSON.stringify(participants) %>;
    const ctx = document.getElementById('availability-heatmap').getContext('2d');
    const participantsList = document.getElementById('participant-colors');
    const bestTimeDiv = document.getElementById('best-time');

    // Generate color palette
    const colorPalette = generateColorPalette(participants.length);

    // Prepare data for heatmap
    const heatmapData = [];
    const timeSlots = new Array(24 * 4).fill(0); // 15-minute intervals

    participants.forEach((participant, index) => {
        const startMinutes = convertToUTCMinutes(participant.start_time, participant.timezone);
        const endMinutes = convertToUTCMinutes(participant.end_time, participant.timezone);

        // Add participant to the list with color
        const listItem = document.createElement('li');
        listItem.innerHTML = `<span style="color: ${colorPalette[index]}">‚óè</span> ${participant.name} (${participant.timezone}): ${participant.start_time} - ${participant.end_time}`;
        participantsList.appendChild(listItem);

        // Fill heatmap data
        for (let i = Math.floor(startMinutes / 15); i < Math.ceil(endMinutes / 15); i++) {
            if (i >= 0 && i < timeSlots.length) {
                timeSlots[i]++;
            }
        }
    });

    // Create heatmap data
    for (let i = 0; i < timeSlots.length; i++) {
        heatmapData.push({
            x: i,
            y: 0,
            v: timeSlots[i]
        });
    }

    // Find best meeting time
    const maxOverlap = Math.max(...timeSlots);
    const bestStartIndex = timeSlots.indexOf(maxOverlap);
    const bestEndIndex = timeSlots.lastIndexOf(maxOverlap);
    const bestStartTime = formatMinutes(bestStartIndex * 15);
    const bestEndTime = formatMinutes((bestEndIndex + 1) * 15);

    bestTimeDiv.innerHTML = `<strong>Best Meeting Time:</strong> ${bestStartTime} - ${bestEndTime} UTC (${maxOverlap} participants)`;

    new Chart(ctx, {
        type: 'matrix',
        data: {
            datasets: [{
                label: 'Participant Overlap',
                data: heatmapData,
                backgroundColor: ({ v }) => {
                    const alpha = v / participants.length;
                    return `rgba(0, 128, 0, ${alpha})`;
                },
                width: ({ chart }) => (chart.chartArea || {}).width / 96,
                height: 40
            }]
        },
        options: {
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        title: (context) => {
                            const startTime = formatMinutes(context[0].raw.x * 15);
                            const endTime = formatMinutes(context[0].raw.x * 15 + 15);
                            return `${startTime} - ${endTime} UTC`;
                        },
                        label: (context) => `${context.raw.v} participant(s) available`
                    }
                }
            },
            scales: {
                x: {
                    type: 'linear',
                    min: 0,
                    max: 95,
                    ticks: {
                        stepSize: 4,
                        callback: value => formatMinutes(value * 15)
                    },
                    title: {
                        display: true,
                        text: 'Time (UTC)'
                    }
                },
                y: {
                    display: false
                }
            }
        }
    });
});

function convertToUTCMinutes(time, timezone) {
    return moment.tz(`2023-01-01 ${time}`, timezone).utc().diff(moment.utc('2023-01-01'), 'minutes');
}

function formatMinutes(minutes) {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
}

function generateColorPalette(count) {
    const palette = [];
    for (let i = 0; i < count; i++) {
        const hue = (i * 360 / count) % 360;
        palette.push(`hsl(${hue}, 70%, 50%)`);
    }
    return palette;
}
</script>
</body>
</html>